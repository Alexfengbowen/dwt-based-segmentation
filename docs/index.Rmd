---
title: 'DWT-based segmentation on trajectories of turkey vultures'
author: "Merlin Unterfinger"
date: "`r Sys.Date()`"
output:
    html_document:
      code_folding: hide
      fig_caption: yes
      highlight: tango
      number_sections: no
      theme: journal
      toc: yes
      toc_depth: 2
      toc_float: yes
biblio-style: "apalike"
link-citations: true
filter: pandoc-eqnos
bibliography: References.bib
abstract: "This script explains the procedure from Soleymani et al. 2017 for applying DWT-based segmentation on trajectories of turkey vultures. The original code is written in MatLab. This is a direct portation of the MatLab code to R. Some functions from MatLab are not available in R, therefore some workarounds and implementations heave been done, which might lead to slightly different results."
---

<style>
body {
text-align: justify}
</style>


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.show = 'hold')
rm(list = ls())
setwd('..')
source("R/findpeaks.R")
cat("\014")
```

# Background
Method description by [@Soleymani]:

In the following, a step-by-step guideline for the application of the DWT-based method will be provided. An overview of these steps is given in Figure S2a.
                                                                                                                                      Figure S2a: Flowchart of the DWT segmentation method
In Step 1, the movement parameter profile (i.e. time series of the chosen movement parameter; speed in our example) is calculated from the raw movement data, acting as the input for the DWT transform. In Step 2, the movement signal is decomposed by the DWT. This transformation yields two outputs: low frequency approximation sub- bands (3a) and high frequency detail sub-bands (3b). These two resulting sets of sub- bands will be used for different purposes in the next stage and therefore the procedure bifurcates into two different branches, along which different analyses will be performed. Peak analysis will be performed on approximation sub-bands (Step 4a) in order to obtain behavioural segments (Step 5a), while thresholding of detail sub-bands (Step 4b) will be used to detect behavioural change points (Step 5b).

# Data
```{r, warning =  FALSE, message=FALSE}
# Reading the input file (speed and annotations)
setwd('..')
rawData <- readr::read_csv("data/Turkey-Vulture-Steamhouse 2.csv")
nanIdx <- which(is.na(rawData$computedSpeed))
speed <- rawData$computedSpeed
states <- rawData$http...vocabulary.movebank.org.extended.raptor.workshop.attributes.migration.state
speed <- speed[-nanIdx]
states <- states[-nanIdx]
statesCh <- numeric(length(speed)) + 1

# Check for empty strings
for (i in 2:length(states))
{
  if (states[i] == '') {
    states[i]=states[i-1]
  }
  statesCh[i] = states[i] == states[i-1]
}

statesChange=which(statesCh==0)
statesLen = c(statesChange[1]-1, diff(statesChange), length(states)-tail(statesChange,1))
tt = seq(1, length(speed))

# Plotting step length profile versus annotations
par(mfrow = c(2, 1), mar=c(0.1,4,0.8,2)+0.1, oma=c(5,0,3,0)+0.1, xaxt='n')
plot(speed, type = "l", xlim=c(1, length(speed)+2000), col = "blue", ylab = 'Speed(km/h)', main = "Profile of speed over time")
plot(speed, type = "p", pch=16, xlim=c(1, length(speed)+2000),col = as.factor(states), ylab = 'Speed(km/h)', main = "Annotation data")
legend("topright", legend=levels(as.factor(states)), pch=16, pt.cex=1, cex = 0.5, col=unique(as.factor(states)))
```

# Discrete wavlet transform
For both the approximation and the detail sub-bands, the selection of 
appropriate decomposition levels is done by visual inspection of the sub-bands [...] [@Soleymani]"
```{r}
# Specify levels of DWT
L <- 10

# Discrete wavelet transform
sig <- speed
DWT <- wavelets::modwt(sig, filter="d4", n.levels = L)
a <- DWT@V # approximation sub-bands
d <- DWT@W # detail sub-bands

# Plot sub-bands
par(mfrow=c(L+1,1), mar=c(0,4,0,2)+0.1, oma=c(5,0,3,0)+0.1, xaxt='n')
# Approximation sub-bands
plot(sig, type = "l", col = "red",ylab = "s")
for (i in 1:L) {
  plot(a[[i]], type = "l", col = "blue", ylab = paste("a", i, sep=""))
}
# Detail sub-bands
title("Signal and approximation sub-bands", outer=TRUE)
plot(sig, type = "l", col = "red",ylab = "s")
for (i in 1:L) {
  plot(d[[i]], type = "l", col = rgb(0.2, 0.6, 0.2), ylab = paste("d", i, sep=""))
}
title("Signal and detail sub-bands", outer=TRUE)
```

# Approximation sub-bands
## Peak analysis
The thresholds for the peak height (peak_threshold) are selected by visual inspection,
that is, by selecting the values of lower peaks as thresh- olds to detect the segments
of higher peaks [@Soleymani]"

```{r}
# Finding the extremum values: in this case it is maxima
minHeight <-  3.5
minDist <- 1000
aBandNumber <- 7
par(mfrow=c(1,1), mar=c(0,4,0,2)+0.1, oma=c(5,0,3,0)+0.1, xaxt='s')
pks <- findpeaks(c(a[[aBandNumber]]), minpeakheight = minHeight, minpeakdistance = minDist, plot = TRUE)
Pks <- pks[,1]
PksLoc <- pks[,2]
PksWid <- pks[,3]
PksPro <- pks[,4]
```

## Segmentation based on the extents of peaks
```{r}
PksPoints <- matrix(NA, nrow(pks), 2)
for (i in 1:nrow(pks)) {
  widR = round(PksWid[i])
  slot = (PksLoc[i]-widR):(PksLoc[i]+widR)
  if (tail(slot,1) > length(a[[aBandNumber]])){
    fend = which(slot == length(a[[aBandNumber]]))
    slot = slot[1:fend]
  }
  val = Pks[i] - PksPro[i]/2 # the value of half of the height of the peak
  z = a[[aBandNumber]][slot]
  dist = sort(abs(a[[aBandNumber]][slot] - val))
  l1 = which(abs(z-val) == dist[1])
  l2 = which(abs(z-val) == dist[2])
  
  for (j in 2:length(dist)) {
    l22 = which(abs(z-val) == dist[j])
    if (sign(slot[l1] - PksLoc[i]) != sign(slot[l22] - PksLoc[i])) {
      l2 = l22
      break 
    }
  }
  PksPoints[i,] = sort(c(slot[l1], slot[l2]))
}

seg = PksPoints[1,] 
for (i in 2:nrow(PksPoints)) {
  seg = c(seg, PksPoints[i,])
}
fseg = c(1, seg, length(a[[aBandNumber]]))

segments <- numeric(length(a[[aBandNumber]]))
for (i in 1:length(a[[aBandNumber]])) {
  for (j in 2:length(fseg)) {
    segments[fseg[j-1]:fseg[j]] = j-1;
  }
}
```

## Segmentation based on the extents of peaks
```{r}
par(mfrow=c(4,1), mar=c(1,4,1,2)+0.1, oma=c(5,0,3,0)+0.1, xaxt='n')
# Ploting the original signal
plot(sig, type = "l", col = "blue", xlim=c(1, length(speed)+2000), ylab = 'Speed(km/h)', main = "a) Speed profile of Steamhouse 2")
# Approximation sub-band and the detected peaks
plot(a[[aBandNumber]], type = "l", col = "blue", xlim=c(1, length(speed)+2000), ylab = 'Approximation sub-band', main = paste("b) Detected peaks at approximation sub-band of level", aBandNumber))
points(pks[,2], pks[,1]+0.25, pch = 25, bg="blue")
palette(c("red","green3", "blue", "cyan"))
# Results of segmentation based on the extents (widths) of peaks
plot(speed, type = "p", pch=16, xlim=c(1, length(speed)+2000),col = as.factor(segments), ylab = 'Speed(km/h)', main = "c) Segmentation results based on DWT")
legend("topright", legend=levels(as.factor(segments)), pch=16, pt.cex=1, cex = 0.5, col=unique(as.factor(segments)))
# Annotations
plot(speed, type = "p", pch=16, xlim=c(1, length(speed)+2000),col = as.factor(states), ylab = 'Speed(km/h)', xlab = 'Years', main = "d) Annotated data")
legend("topright", legend=levels(as.factor(states)), pch=16, pt.cex=1, cex = 0.5, col=unique(as.factor(states)))
```

# Detail sub-bands
## Choose detail sub-band
```{r}
dBandNumber <- 5
det <- d[[dBandNumber]]
par(mfrow=c(1,1), mar=c(1,4,1,2)+0.1, oma=c(5,0,3,0)+0.1, xaxt='s')
plot(det, type = "l", col = rgb(0.2, 0.6, 0.2), ylab = 'Approximation sub-band', main = paste("Detail sub-band", dBandNumber))
```

## Initial segments based on thresholding
```{r}
# Labeling based on thresholding neighboring fixes passing the threshold
segL <- c(det[1,1], 1)
id <- 1
f <- as.numeric(diff(abs(det[,1])) > 1)
f <- c(0, f)
for (i in (2:length(det))) {
  if (f[i] == 0) {
    segLb <- cbind(det[i,1], id)
  } else if (f[i] == 1 && f[i] != f[i-1]) {
    segLb <- cbind(det[i,1], id+1)
    id <- id+1
  } else {
    segLb <- cbind(det[i,1], id)
  } 
  segL <- rbind(segL, segLb)
}
```

## Segmentation based on stitching the detail sub-segments
```{r}

# Detecting frequency breaks
frqdif <- which(diff(abs(det))>1)
frqdif <- c(frqdif, length(det))

# Detecting the initial segments based on thresholding
seg <- list()
seg[[1]] <- det[1:frqdif[1]]
for (j in 2:length(frqdif)) {
  if (frqdif[j]-frqdif[j-1]==1) {
    seg[[j]] <- det[frqdif[j]]
  } else {
    seg[[j]] <- det[(frqdif[j-1]+1):frqdif[j]]
  }
}

# Removing short segments (i.e. <500 fixes)
seglen <- sapply(seg, length)
segLongInd <- which(seglen>500)

# Concatenating the segments
segs1 <- list()
segs2 <- list()
for (p in 1:(length(segLongInd)-1)) {
  sumLen1 <- seglen[segLongInd[p]]
  ids1 <- p*(numeric(sumLen1)+1)
  segs1[[p]] <- cbind(seg[[segLongInd[p]]], ids1)
  sumLen2 <- seglen[segLongInd[p]+1]
  segsBTW <- seg[[(segLongInd[p]+1)]] # Not shure here!
  from <- (segLongInd[p]+2)
  to <- (segLongInd[p+1]-1)
  if (from <= to) {
    for (q in from:to) {
      sumLen2 <- sumLen2+seglen[q]
      segsBTW <- c(segsBTW, seg[[q]])
    }
  }
  ids2 <- (p+50)*(numeric(sumLen2)+1)
  segs2[[p]] <- cbind(segsBTW, ids2)
  if (length(segs2[[p]])<100) {
    ids2=p*((numeric(sumLen2))+1)
    segs1[[p]] <- rbind(segs1[[p]], cbind(segsBTW, ids2)) # Not shure here!
    segs2[[p]] <- numeric(0)
  }
}
segsEnd <- seg[[segLongInd[p+1]]]
sumLenEnd <- seglen[segLongInd[p+1]]
from <- (segLongInd[p+1]+1)
to <- (length(seg))
if (from <= to) {
  for (k in from:to) {
    sumLenEnd <- sumLenEnd+seglen[k]
    segsEnd <- c(segsEnd, seg[[k]])
  }
}
idsEnd <- (p+1)*(numeric(sumLenEnd)+1)
segs1[[p+1]] <- cbind(segsEnd, idsEnd)
segs2[[p+1]] <- numeric(0)
segments <- rbind(segs1[[1]], segs2[[1]])
for (m in 2:length(segs1)) {
  segNext <- rbind(segs1[[m]], segs2[[m]])
  segments <- rbind(segments, segNext)
}
segments <- cbind(segments, numeric(nrow(segments)))
segments[1,3] <- 1
for (i in 2:nrow(segments)) {
  segID <- segments[i-1,3]
  if (segments[i,2] == segments[i-1,2]) {
    segments[i,3] <- segID
  } else {
    segments[i,3] <- segments[i-1,3] + 1
    segID <- segID + 1
  }
}
```

## Results
```{r}
# Figure 6
par(mfrow=c(4,1), mar=c(1,4,1,2)+0.1, oma=c(5,0,3,0)+0.1, xaxt='n')
# Overlaying detail sub-band over the states
plot(tt, det, type = "p", pch=16, xlim=c(1, length(speed)+2000),col = as.factor(states), ylab = 'Detail sub-band', main = "a) Detail sub-bands over the annotated states")
legend("topright", legend=levels(as.factor(states)), pch=16, pt.cex=1, cex = 0.5, col=unique(as.factor(states)))
lines(tt, det)
# Plotting initial segments based on thresholding
plot(tt, speed, type = "p", pch=16, xlim=c(1, length(speed)+2000),col = as.factor(segL[,2]), ylab = 'Speed(km/h)', xlab = 'Years', main = "b) Initial segments based on thresholding")
# Results of segmentation based stitching the detail sub-segments
plot(tt, speed, type = "p", pch=16, xlim=c(1, length(speed)+2000),col = as.factor(segments[,3]), ylab = 'Speed(km/h)', xlab = 'Years', main = "c) Segmentation based on stitching the detail sub-segments")
# Annotations
plot(tt, speed, type = "p", pch=16, xlim=c(1, length(speed)+2000),col = as.factor(states), ylab = 'Detail sub-band', main = "d) Annotated data")
legend("topright", legend=levels(as.factor(states)), pch=16, pt.cex=1, cex = 0.5, col=unique(as.factor(states)))
```

# References